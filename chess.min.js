/*
 * Copyright (c) 2019, Matt Michel (@ninjaPixel)
 * Copyright (c) 2018, Jeff Hlywa (jhlywa@gmail.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *----------------------------------------------------------------------------*/
/* minified license below  */
/* @license
 * Copyright (c) 2018, Jeff Hlywa (jhlywa@gmail.com)
 * Released under the BSD license
 * https://github.com/jhlywa/chess.js/blob/master/LICENSE
 */
var Chess=function(r){function e(r){void 0===r&&(r=!1),ur=new Array(128),lr={w:x,b:x},sr=U,pr={w:0,b:0},cr=x,vr=0,gr=1,hr=[],r||(Er={}),a(i())}function n(){t(H)}function t(r,n){void 0===n&&(n=!1);var t=r.split(/\s+/),f=t[0],u=0;if(!o(r).valid)return!1;e(n);for(var s=0;s<f.length;s++){var p=f.charAt(s);if("/"===p)u+=8;else if(O(p))u+=parseInt(p,10);else{var c=p<"a"?U:Q;l({type:p.toLowerCase(),color:c},L(u)),u++}}return sr=t[1],t[2].indexOf("K")>-1&&(pr.w|=er.KSIDE_CASTLE),t[2].indexOf("Q")>-1&&(pr.w|=er.QSIDE_CASTLE),t[2].indexOf("k")>-1&&(pr.b|=er.KSIDE_CASTLE),t[2].indexOf("q")>-1&&(pr.b|=er.QSIDE_CASTLE),cr="-"===t[3]?x:fr[t[3]],vr=parseInt(t[4],10),gr=parseInt(t[5],10),a(i()),!0}/* TODO: this function is pretty much crap - it validates structure but
   * completely ignores content (e.g. doesn't verify that each side has a king)
   * ... we should rewrite this, and ditch the silly error_number field while
   * we're at it
   */
function o(r){var e={0:"No errors.",1:"FEN string must contain six space-delimited fields.",2:"6th field (move number) must be a positive integer.",3:"5th field (half move counter) must be a non-negative integer.",4:"4th field (en-passant square) is invalid.",5:"3rd field (castling availability) is invalid.",6:"2nd field (side to move) is invalid.",7:"1st field (piece positions) does not contain 8 '/'-delimited rows.",8:"1st field (piece positions) is invalid [consecutive numbers].",9:"1st field (piece positions) is invalid [invalid piece].",10:"1st field (piece positions) is invalid [row too large].",11:"Illegal en-passant square"},n=r.split(/\s+/);if(6!==n.length)return{valid:!1,error_number:1,error:e[1]};/* 2nd criterion: move number field is a integer value > 0? */
if(isNaN(n[5])||parseInt(n[5],10)<=0)return{valid:!1,error_number:2,error:e[2]};/* 3rd criterion: half move counter is an integer >= 0? */
if(isNaN(n[4])||parseInt(n[4],10)<0)return{valid:!1,error_number:3,error:e[3]};/* 4th criterion: 4th field is a valid e.p.-string? */
if(!/^(-|[abcdefgh][36])$/.test(n[3]))return{valid:!1,error_number:4,error:e[4]};/* 5th criterion: 3th field is a valid castle-string? */
if(!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(n[2]))return{valid:!1,error_number:5,error:e[5]};/* 6th criterion: 2nd field is "w" (white) or "b" (black)? */
if(!/^(w|b)$/.test(n[1]))return{valid:!1,error_number:6,error:e[6]};/* 7th criterion: 1st field contains 8 rows? */
var t=n[0].split("/");if(8!==t.length)return{valid:!1,error_number:7,error:e[7]};/* 8th criterion: every row is valid? */
for(var o=0;o<t.length;o++){for(var i=0,f=!1,a=0;a<t[o].length;a++)if(isNaN(t[o][a])){if(!/^[prnbqkPRNBQK]$/.test(t[o][a]))return{valid:!1,error_number:9,error:e[9]};i+=1,f=!1}else{if(f)return{valid:!1,error_number:8,error:e[8]};i+=parseInt(t[o][a],10),f=!0}if(8!==i)return{valid:!1,error_number:10,error:e[10]}}return"3"==n[3][1]&&"w"==n[1]||"6"==n[3][1]&&"b"==n[1]?{valid:!1,error_number:11,error:e[11]}:{valid:!0,error_number:0,error:e[0]}}function i(){for(var r=0,e="",n=fr.a8;n<=fr.h1;n++){if(null==ur[n])r++;else{r>0&&(e+=r,r=0);var t=ur[n].color,o=ur[n].type;e+=t===U?o.toUpperCase():o.toLowerCase()}n+1&136&&(r>0&&(e+=r),n!==fr.h1&&(e+="/"),r=0,n+=8)}var i="";pr[U]&er.KSIDE_CASTLE&&(i+="K"),pr[U]&er.QSIDE_CASTLE&&(i+="Q"),pr[Q]&er.KSIDE_CASTLE&&(i+="k"),pr[Q]&er.QSIDE_CASTLE&&(i+="q"),/* do we have an empty castling flag? */
i=i||"-";var f=cr===x?"-":L(cr);return[e,sr,i,f,vr,gr].join(" ")}function f(r){for(var e=0;e<r.length;e+=2)"string"==typeof r[e]&&"string"==typeof r[e+1]&&(Er[r[e]]=r[e+1]);return Er}/* called when the initial board setup is changed with put() or remove().
   * modifies the SetUp and FEN properties of the header object.  if the FEN is
   * equal to the default position, the SetUp and FEN are deleted
   * the setup is only updated if history.length is zero, ie moves haven't been
   * made.
   */
function a(r){hr.length>0||(r!==H?(Er.SetUp="1",Er.FEN=r):(delete Er.SetUp,delete Er.FEN))}function u(r){var e=ur[fr[r]];return e?{type:e.type,color:e.color}:null}function l(r,e){/* check for valid piece object */
if(!("type"in r&&"color"in r))return!1;/* check for piece */
if(-1===W.indexOf(r.type.toLowerCase()))return!1;/* check for valid square */
if(!(e in fr))return!1;var n=fr[e];/* don't let the user place more than one king */
/* don't let the user place more than one king */
return(r.type!=G||lr[r.color]==x||lr[r.color]==n)&&(ur[n]={type:r.type,color:r.color},r.type===G&&(lr[r.color]=n),a(i()),!0)}function s(r){var e=u(r);return ur[fr[r]]=null,e&&e.type===G&&(lr[e.color]=x),a(i()),e}function p(r,e,n,t,o){var i={color:sr,from:e,to:n,flags:t,piece:r[e].type};return o&&(i.flags|=er.PROMOTION,i.promotion=o),r[n]?i.captured=r[n].type:t&er.EP_CAPTURE&&(i.captured=j),i}function c(r){function e(r,e,n,t,o){/* if pawn promotion */
if(r[n].type!==j||w(t)!==ir&&w(t)!==nr)e.push(p(r,n,t,o));else for(var i=[F,$,M,B],f=0,a=i.length;f<a;f++)e.push(p(r,n,t,o,i[f]))}var n=[],t=sr,o=N(t),i={b:or,w:tr},f=fr.a8,a=fr.h1,u=!1,l=!(void 0!==r&&"legal"in r)||r.legal;/* are we generating moves for a single square? */
if(void 0!==r&&"square"in r){if(!(r.square in fr))/* invalid square */
return[];f=a=fr[r.square],u=!0}for(var s=f;s<=a;s++)/* did we run off the end of the board */
if(136&s)s+=7;else{var c=ur[s];if(null!=c&&c.color===t)if(c.type===j){/* single square, non-capturing */
var v=s+z[t][0];if(null==ur[v]){e(ur,n,s,v,er.NORMAL);/* double square */
var v=s+z[t][1];i[t]===w(s)&&null==ur[v]&&e(ur,n,s,v,er.BIG_PAWN)}/* pawn captures */
for(g=2;g<4;g++){var v=s+z[t][g];136&v||(null!=ur[v]&&ur[v].color===o?e(ur,n,s,v,er.CAPTURE):v===cr&&e(ur,n,s,cr,er.EP_CAPTURE))}}else for(var g=0,d=J[c.type].length;g<d;g++)for(var b=J[c.type][g],v=s;;){if(136&(v+=b))break;if(null!=ur[v]){if(ur[v].color===t)break;e(ur,n,s,v,er.CAPTURE);break}/* break, if knight or king */
if(e(ur,n,s,v,er.NORMAL),"n"===c.type||"k"===c.type)break}}/* check for castling if: a) we're generating all moves, or b) we're doing
     * single square move generation on the king's square
     */
if(!u||a===lr[t]){/* king-side castling */
if(pr[t]&er.KSIDE_CASTLE){var _=lr[t],A=_+2;null!=ur[_+1]||null!=ur[A]||h(o,lr[t])||h(o,_+1)||h(o,A)||e(ur,n,lr[t],A,er.KSIDE_CASTLE)}/* queen-side castling */
if(pr[t]&er.QSIDE_CASTLE){var _=lr[t],A=_-2;null!=ur[_-1]||null!=ur[_-2]||null!=ur[_-3]||h(o,lr[t])||h(o,_-1)||h(o,A)||e(ur,n,lr[t],A,er.QSIDE_CASTLE)}}/* return all pseudo-legal moves (this includes moves that allow the king
     * to be captured)
     */
if(!l)return n;for(var S=[],s=0,d=n.length;s<d;s++)C(n[s]),E(t)||S.push(n[s]),y();return S}/* convert a move from 0x88 coordinates to Standard Algebraic Notation
   * (SAN)
   *
   * @param {boolean} sloppy Use the sloppy SAN generator to work around over
   * disambiguation bugs in Fritz and Chessbase.  See below:
   *
   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4
   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned
   * 4. ... Ne7 is technically the valid SAN
   */
function v(r,e){var n="";if(r.flags&er.KSIDE_CASTLE)n="O-O";else if(r.flags&er.QSIDE_CASTLE)n="O-O-O";else{var t=T(r,e);r.piece!==j&&(n+=r.piece.toUpperCase()+t),r.flags&(er.CAPTURE|er.EP_CAPTURE)&&(r.piece===j&&(n+=L(r.from)[0]),n+="x"),n+=L(r.to),r.flags&er.PROMOTION&&(n+="="+r.promotion.toUpperCase())}return C(r),d()&&(b()?n+="#":n+="+"),y(),n}
// parses all of the decorators out of a SAN string
function g(r){return r.replace(/=/,"").replace(/[+#]?[?!]*$/,"")}function h(r,e){for(var n=fr.a8;n<=fr.h1;n++)/* did we run off the end of the board */
if(136&n)n+=7;else/* if empty square or wrong color */
if(null!=ur[n]&&ur[n].color===r){var t=ur[n],o=n-e,i=o+119;if(V[i]&1<<Y[t.type]){if(t.type===j){if(o>0){if(t.color===U)return!0}else if(t.color===Q)return!0;continue}/* if the piece is a knight or a king */
if("n"===t.type||"k"===t.type)return!0;for(var f=X[i],a=n+f,u=!1;a!==e;){if(null!=ur[a]){u=!0;break}a+=f}if(!u)return!0}}return!1}function E(r){return h(N(r),lr[r])}function d(){return E(sr)}function b(){return d()&&0===c().length}function _(){return!d()&&0===c().length}function A(){for(var r={},e=[],n=0,t=0,o=fr.a8;o<=fr.h1;o++)if(t=(t+1)%2,136&o)o+=7;else{var i=ur[o];i&&(r[i.type]=i.type in r?r[i.type]+1:1,i.type===M&&e.push(t),n++)}/* k vs. k */
if(2===n)return!0;if(/* k vs. kn .... or .... k vs. kb */
3===n&&(1===r[M]||1===r[B]))return!0;if(n===r[M]+2){for(var f=0,a=e.length,o=0;o<a;o++)f+=e[o];if(0===f||f===a)return!0}return!1}function S(){for(/* TODO: while this function is fine for casual use, a better
     * implementation would use a Zobrist key (instead of FEN). the
     * Zobrist key would be maintained in the make_move/undo_move functions,
     * avoiding the costly that we do below.
     */
var r=[],e={},n=!1;;){var t=y();if(!t)break;r.push(t)}for(;;){/* remove the last two fields in the FEN string, they're not needed
       * when checking for draw by rep */
var o=i().split(" ").slice(0,4).join(" ");if(/* has the position occurred three or move times */
e[o]=o in e?e[o]+1:1,e[o]>=3&&(n=!0),!r.length)break;C(r.pop())}return n}function m(r){hr.push({move:r,kings:{b:lr.b,w:lr.w},turn:sr,castling:{b:pr.b,w:pr.w},ep_square:cr,half_moves:vr,move_number:gr})}function C(r){var e=sr,n=N(e);/* if we moved the king */
if(m(r),ur[r.to]=ur[r.from],ur[r.from]=null,/* if ep capture, remove the captured pawn */
r.flags&er.EP_CAPTURE&&(sr===Q?ur[r.to-16]=null:ur[r.to+16]=null),/* if pawn promotion, replace with new piece */
r.flags&er.PROMOTION&&(ur[r.to]={type:r.promotion,color:e}),ur[r.to].type===G){/* if we castled, move the rook next to the king */
if(lr[ur[r.to].color]=r.to,r.flags&er.KSIDE_CASTLE){var t=r.to-1,o=r.to+1;ur[t]=ur[o],ur[o]=null}else if(r.flags&er.QSIDE_CASTLE){var t=r.to+1,o=r.to-2;ur[t]=ur[o],ur[o]=null}/* turn off castling */
pr[e]=""}/* turn off castling if we move a rook */
if(pr[e])for(var i=0,f=ar[e].length;i<f;i++)if(r.from===ar[e][i].square&&pr[e]&ar[e][i].flag){pr[e]^=ar[e][i].flag;break}/* turn off castling if we capture a rook */
if(pr[n])for(var i=0,f=ar[n].length;i<f;i++)if(r.to===ar[n][i].square&&pr[n]&ar[n][i].flag){pr[n]^=ar[n][i].flag;break}/* if big pawn move, update the en passant square */
cr=r.flags&er.BIG_PAWN?"b"===sr?r.to-16:r.to+16:x,/* reset the 50 move counter if a pawn is moved or a piece is captured */
r.piece===j?vr=0:r.flags&(er.CAPTURE|er.EP_CAPTURE)?vr=0:vr++,sr===Q&&gr++,sr=N(sr)}function y(){var r=hr.pop();if(null==r)return null;var e=r.move;lr=r.kings,sr=r.turn,pr=r.castling,cr=r.ep_square,vr=r.half_moves,gr=r.move_number;var n=sr,t=N(sr);if(ur[e.from]=ur[e.to],ur[e.from].type=e.piece,// to undo any promotions
ur[e.to]=null,e.flags&er.CAPTURE)ur[e.to]={type:e.captured,color:t};else if(e.flags&er.EP_CAPTURE){var o;o=n===Q?e.to-16:e.to+16,ur[o]={type:j,color:t}}if(e.flags&(er.KSIDE_CASTLE|er.QSIDE_CASTLE)){var i,f;e.flags&er.KSIDE_CASTLE?(i=e.to+1,f=e.to-1):e.flags&er.QSIDE_CASTLE&&(i=e.to-2,f=e.to+1),ur[i]=ur[f],ur[f]=null}return e}/* this function is used to uniquely identify ambiguous moves */
function T(r,e){for(var n=c({legal:!e}),t=r.from,o=r.to,i=r.piece,f=0,a=0,u=0,l=0,s=n.length;l<s;l++){var p=n[l].from,v=n[l].to;/* if a move of the same piece type ends on the same to square, we'll
       * need to add a disambiguator to the algebraic notation
       */
i===n[l].piece&&t!==p&&o===v&&(f++,w(t)===w(p)&&a++,R(t)===R(p)&&u++)}/* if there exists a similar moving piece on the same rank and file as
       * the move in question, use the square as the disambiguator
       */
return f>0?a>0&&u>0?L(t):u>0?L(t).charAt(1):L(t).charAt(0):""}function I(){for(var r="   +------------------------+\n",e=fr.a8;e<=fr.h1;e++){/* empty piece */
if(/* display the rank */
0===R(e)&&(r+=" "+"87654321"[w(e)]+" |"),null==ur[e])r+=" . ";else{var n=ur[e].type;r+=" "+(ur[e].color===U?n.toUpperCase():n.toLowerCase())+" "}e+1&136&&(r+="|\n",e+=8)}return r+="   +------------------------+\n",r+="     a  b  c  d  e  f  g  h\n"}
// convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates
function P(r,e){
// strip off any move decorations: e.g Nf3+?!
var n=g(r);
// if we're using the sloppy parser run a regex to grab piece, to, and from
// this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7
if(e){var t=n.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);if(t)var o=t[1],i=t[2],f=t[3],a=t[4]}for(var u=c(),l=0,s=u.length;l<s;l++){
// try the strict parser first, then the sloppy parser if requested
// by the user
if(n===g(v(u[l]))||e&&n===g(v(u[l],!0)))return u[l];if(t&&(!o||o.toLowerCase()==u[l].piece)&&fr[i]==u[l].from&&fr[f]==u[l].to&&(!a||a.toLowerCase()==u[l].promotion))return u[l]}return null}/*****************************************************************************
   * UTILITY FUNCTIONS
   ****************************************************************************/
function w(r){return r>>4}function R(r){return 15&r}function L(r){var e=R(r),n=w(r);return"abcdefgh".substring(e,e+1)+"87654321".substring(n,n+1)}function N(r){return r===U?Q:U}function O(r){return-1!=="0123456789".indexOf(r)}/* pretty = external move object */
function k(r){var e=q(r);const n=v(e,!1);e.san=n,e.to=L(e.to),e.from=L(e.from);var t="";for(var o in er)er[o]&e.flags&&(t+=rr[o]);e.flags=t;const i=n.charAt(n.length-1),f="#"===i,a="+"===i;return e.check=a,e.checkMate=f,e}function q(r){var e=r instanceof Array?[]:{};for(var n in r)e[n]="object"==typeof n?q(r[n]):r[n];return e}function D(r){return r.replace(/^\s+|\s+$/g,"")}/*****************************************************************************
   * DEBUGGING UTILITIES
   ****************************************************************************/
function K(r){for(var e=c({legal:!1}),n=0,t=sr,o=0,i=e.length;o<i;o++){if(C(e[o]),!E(t))if(r-1>0){var f=K(r-1);n+=f}else n++;y()}return n}var Q="b",U="w",x=-1,j="p",B="n",M="b",$="r",F="q",G="k",W="pnbrqkPNBRQK",H="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",Z=["1-0","0-1","1/2-1/2","*"],z={b:[16,32,17,15],w:[-16,-32,-17,-15]},J={n:[-18,-33,-31,-14,18,33,31,14],b:[-17,-15,17,15],r:[-16,1,16,-1],q:[-17,-16,-15,1,17,16,15,-1],k:[-17,-16,-15,1,17,16,15,-1]},V=[20,0,0,0,0,0,0,24,0,0,0,0,0,0,20,0,0,20,0,0,0,0,0,24,0,0,0,0,0,20,0,0,0,0,20,0,0,0,0,24,0,0,0,0,20,0,0,0,0,0,0,20,0,0,0,24,0,0,0,20,0,0,0,0,0,0,0,0,20,0,0,24,0,0,20,0,0,0,0,0,0,0,0,0,0,20,2,24,2,20,0,0,0,0,0,0,0,0,0,0,0,2,53,56,53,2,0,0,0,0,0,0,24,24,24,24,24,24,56,0,56,24,24,24,24,24,24,0,0,0,0,0,0,2,53,56,53,2,0,0,0,0,0,0,0,0,0,0,0,20,2,24,2,20,0,0,0,0,0,0,0,0,0,0,20,0,0,24,0,0,20,0,0,0,0,0,0,0,0,20,0,0,0,24,0,0,0,20,0,0,0,0,0,0,20,0,0,0,0,24,0,0,0,0,20,0,0,0,0,20,0,0,0,0,0,24,0,0,0,0,0,20,0,0,20,0,0,0,0,0,0,24,0,0,0,0,0,0,20],X=[17,0,0,0,0,0,0,16,0,0,0,0,0,0,15,0,0,17,0,0,0,0,0,16,0,0,0,0,0,15,0,0,0,0,17,0,0,0,0,16,0,0,0,0,15,0,0,0,0,0,0,17,0,0,0,16,0,0,0,15,0,0,0,0,0,0,0,0,17,0,0,16,0,0,15,0,0,0,0,0,0,0,0,0,0,17,0,16,0,15,0,0,0,0,0,0,0,0,0,0,0,0,17,16,15,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,-15,-16,-17,0,0,0,0,0,0,0,0,0,0,0,0,-15,0,-16,0,-17,0,0,0,0,0,0,0,0,0,0,-15,0,0,-16,0,0,-17,0,0,0,0,0,0,0,0,-15,0,0,0,-16,0,0,0,-17,0,0,0,0,0,0,-15,0,0,0,0,-16,0,0,0,0,-17,0,0,0,0,-15,0,0,0,0,0,-16,0,0,0,0,0,-17,0,0,-15,0,0,0,0,0,0,-16,0,0,0,0,0,0,-17],Y={p:0,n:1,b:2,r:3,q:4,k:5},rr={NORMAL:"n",CAPTURE:"c",BIG_PAWN:"b",EP_CAPTURE:"e",PROMOTION:"p",KSIDE_CASTLE:"k",QSIDE_CASTLE:"q"},er={NORMAL:1,CAPTURE:2,BIG_PAWN:4,EP_CAPTURE:8,PROMOTION:16,KSIDE_CASTLE:32,QSIDE_CASTLE:64},nr=7,tr=6,or=1,ir=0,fr={a8:0,b8:1,c8:2,d8:3,e8:4,f8:5,g8:6,h8:7,a7:16,b7:17,c7:18,d7:19,e7:20,f7:21,g7:22,h7:23,a6:32,b6:33,c6:34,d6:35,e6:36,f6:37,g6:38,h6:39,a5:48,b5:49,c5:50,d5:51,e5:52,f5:53,g5:54,h5:55,a4:64,b4:65,c4:66,d4:67,e4:68,f4:69,g4:70,h4:71,a3:80,b3:81,c3:82,d3:83,e3:84,f3:85,g3:86,h3:87,a2:96,b2:97,c2:98,d2:99,e2:100,f2:101,g2:102,h2:103,a1:112,b1:113,c1:114,d1:115,e1:116,f1:117,g1:118,h1:119},ar={w:[{square:fr.a1,flag:er.QSIDE_CASTLE},{square:fr.h1,flag:er.KSIDE_CASTLE}],b:[{square:fr.a8,flag:er.QSIDE_CASTLE},{square:fr.h8,flag:er.KSIDE_CASTLE}]},ur=new Array(128),lr={w:x,b:x},sr=U,pr={w:0,b:0},cr=x,vr=0,gr=1,hr=[],Er={};/* if the user passes in a fen string, load it, else default to
   * starting position
   */
return t(void 0===r?H:r),{/***************************************************************************
     * PUBLIC CONSTANTS (is there a better way to do this?)
     **************************************************************************/
WHITE:U,BLACK:Q,PAWN:j,KNIGHT:B,BISHOP:M,ROOK:$,QUEEN:F,KING:G,SQUARES:function(){for(var r=[],e=fr.a8;e<=fr.h1;e++)136&e?e+=7:r.push(L(e));return r}(),FLAGS:rr,/***************************************************************************
     * PUBLIC API
     **************************************************************************/
load:function(r){return t(r)},reset:function(){return n()},moves:function(r){for(var e=c(r),n=[],t=0,o=e.length;t<o;t++)/* does the user want a full move object (most likely not), or just
         * SAN
         */
void 0!==r&&"verbose"in r&&r.verbose?n.push(k(e[t])):n.push(v(e[t],!1));return n},inCheck:function(){return d()},inCheckmate:function(){return b()},inStalemate:function(){return _()},inDraw:function(){return vr>=100||_()||A()||S()},insufficientMaterial:function(){return A()},inThreefoldRepetition:function(){return S()},gameOver:function(){return vr>=100||b()||_()||A()||S()},validateFen:function(r){return o(r)},fen:function(){return i()},board:function(){for(var r=[],e=[],n=fr.a8;n<=fr.h1;n++)null==ur[n]?e.push(null):e.push({type:ur[n].type,color:ur[n].color}),n+1&136&&(r.push(e),e=[],n+=8);return r},pgn:function(r){/* using the specification from http://www.chessclub.com/help/PGN-spec
       * example for html usage: .pgn({ max_width: 72, newline_char: "<br />" })
       */
var e="object"==typeof r&&"string"==typeof r.newline_char?r.newline_char:"\n",n="object"==typeof r&&"number"==typeof r.max_width?r.max_width:0,t=[],o=!1;/* add the PGN header headerrmation */
for(var i in Er)/* TODO: order of enumerated properties in header object is not
         * guaranteed, see ECMA-262 spec (section 12.6.4)
         */
t.push("["+i+' "'+Er[i]+'"]'+e),o=!0;o&&hr.length&&t.push(e);for(/* pop all of history onto reversed_history */
var f=[];hr.length>0;)f.push(y());/* build the list of moves.  a move_string looks like: "3. e3 e6" */
for(var a=[],u="";f.length>0;){var l=f.pop();/* if the position started with black to move, start PGN with 1. ... */
hr.length||"b"!==l.color?"w"===l.color&&(/* store the previous generated move_string if we have one */
u.length&&a.push(u),u=gr+"."):u=gr+". ...",u=u+" "+v(l,!1),C(l)}/* history should be back to what is was before we started generating PGN,
       * so join together moves
       */
if(/* are there any other leftover moves? */
u.length&&a.push(u),/* is there a result? */
void 0!==Er.Result&&a.push(Er.Result),0===n)return t.join("")+a.join(" ");for(var s=0,i=0;i<a.length;i++)/* if the current move will push past max_width */
s+a[i].length>n&&0!==i?(/* don't end the line with whitespace */
" "===t[t.length-1]&&t.pop(),t.push(e),s=0):0!==i&&(t.push(" "),s++),t.push(a[i]),s+=a[i].length;return t.join("")},loadPgn:function(r,e){function o(r){return r.replace(/\\/g,"\\")}
// allow the user to specify the sloppy move parser to work around over
// disambiguation bugs in Fritz and Chessbase
var i=void 0!==e&&"sloppy"in e&&e.sloppy,a="object"==typeof e&&"string"==typeof e.newline_char?e.newline_char:"\r?\n",u=new RegExp("^(\\[((?:"+o(a)+")|.)*\\])(?:"+o(a)+"){2}"),l=u.test(r)?u.exec(r)[1]:"";
// Put the board in the starting position
n();/* parse PGN header */
var s=function(r,e){for(var n="object"==typeof e&&"string"==typeof e.newline_char?e.newline_char:"\r?\n",t={},i=r.split(new RegExp(o(n))),f="",a="",u=0;u<i.length;u++)f=i[u].replace(/^\[([A-Z][A-Za-z]*)\s.*\]$/,"$1"),a=i[u].replace(/^\[[A-Za-z]+\s"(.*)"\]$/,"$1"),D(f).length>0&&(t[f]=a);return t}(l,e);for(var p in s)f([p,s[p]]);/* load the starting position indicated by [Setup '1'] and
      * [FEN position] */
if("1"===s.SetUp&&!("FEN"in s&&t(s.FEN,!0)))
// second argument to load: don't clear the headers
return!1;/* delete header to get the moves */
var c=r.replace(l,"").replace(new RegExp(o(a),"g")," ");/* delete comments */
c=c.replace(/(\{[^}]+\})+?/g,"");for(/* delete recursive annotation variations */
var v=/(\([^\(\)]+\))+?/g;v.test(c);)c=c.replace(v,"");/* delete move numbers */
c=c.replace(/\d+\.(\.\.)?/g,""),/* delete ... indicating black to move */
c=c.replace(/\.\.\./g,""),/* delete numeric annotation glyphs */
c=c.replace(/\$\d+/g,"");/* trim and get array of moves */
var g=D(c).split(new RegExp(/\s+/));/* delete empty entries */
g=g.join(",").replace(/,,+/g,",").split(",");for(var h="",E=0;E<g.length-1;E++){/* move not possible! (don't clear the board to examine to show the
         * latest valid position)
         */
if(null==(h=P(g[E],i)))return!1;C(h)}if(/* examine last move */
h=g[g.length-1],Z.indexOf(h)>-1)(function(r){for(var e in r)return!0;return!1})(Er)&&void 0===Er.Result&&f(["Result",h]);else{if(null==(h=P(h,i)))return!1;C(h)}return!0},header:function(){return f(arguments)},ascii:function(){return I()},turn:function(){return sr},move:function(r,e){/* The move function can be called with in the following parameters:
       *
       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string
       *
       * .move({ from: 'h7', <- where the 'move' is a move object (additional
       *         to :'h8',      fields are ignored)
       *         promotion: 'q',
       *      })
       */
// allow the user to specify the sloppy move parser to work around over
// disambiguation bugs in Fritz and Chessbase
var n=void 0!==e&&"sloppy"in e&&e.sloppy,t=null;if("string"==typeof r)t=P(r,n);else if("object"==typeof r)/* convert the pretty move object to an ugly move object */
for(var o=c(),i=0,f=o.length;i<f;i++)if(!(r.from!==L(o[i].from)||r.to!==L(o[i].to)||"promotion"in o[i]&&r.promotion!==o[i].promotion)){t=o[i];break}/* failed to find move */
if(!t)return null;/* need to make a copy of move because we can't generate SAN after the
       * move is made
       */
var a=k(t);return C(t),a},undo:function(){var r=y();return r?k(r):null},clear:function(){return e()},put:function(r,e){return l(r,e)},get:function(r){return u(r)},remove:function(r){return s(r)},perft:function(r){return K(r)},squareColor:function(r){if(r in fr){var e=fr[r];return(w(e)+R(e))%2==0?"light":"dark"}return null},history:function(r){for(var e=[],n=[],t=(void 0!==r&&"verbose"in r&&r.verbose);hr.length>0;)e.push(y());for(;e.length>0;){var o=e.pop();t?n.push(k(o)):n.push(v(o)),C(o)}return n}}};/* export Chess object if using node or any other CommonJS compatible
 * environment */
"undefined"!=typeof exports&&(exports.Chess=Chess),/* export Chess object for any RequireJS compatible environment */
"undefined"!=typeof define&&define(function(){return Chess});
